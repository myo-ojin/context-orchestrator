# Context Orchestrator - PowerShell CLI Recording Wrapper
# Automatically wraps claude/codex commands to record sessions

<#
.SYNOPSIS
    Setup CLI recording wrapper for Context Orchestrator

.DESCRIPTION
    This script installs PowerShell functions that wrap claude/codex commands
    to automatically record sessions to Context Orchestrator.

.PARAMETER Install
    Install the wrapper functions to PowerShell profile

.PARAMETER Uninstall
    Remove the wrapper functions from PowerShell profile

.EXAMPLE
    .\setup_cli_recording.ps1 -Install
#>

param(
    [switch]$Install,
    [switch]$Uninstall
)

# Get repository root path (parent directory of scripts/)
$RepositoryRoot = Split-Path -Parent $PSScriptRoot
$RepositoryRoot = $RepositoryRoot -replace '\\', '\\'  # Escape backslashes for string embedding

$WrapperFunctions = @"
# Context Orchestrator CLI Recording Wrapper
# Generated by setup_cli_recording.ps1

# Repository root path (set during installation)
`$script:ContextOrchestratorRoot = "$RepositoryRoot"

# Check if we're in an internal call (prevent recursion)
function Test-IsInternalCall {
    return $env:CONTEXT_ORCHESTRATOR_INTERNAL -eq "1"
}

# Generate session ID
function New-SessionId {
    return "session-$(Get-Date -Format 'yyyyMMdd-HHmmss')-$([guid]::NewGuid().ToString().Substring(0,8))"
}

# Resolve the real CLI shim instead of assuming an .exe is present
function Resolve-CommandShim {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name
    )

    $command = Get-Command $Name -CommandType Application,ExternalScript -ErrorAction SilentlyContinue | Select-Object -First 1

    if (-not $command) {
        throw "Context Orchestrator CLI recording wrapper could not locate '$Name'. Ensure it is installed and on PATH."
    }

    return $command.Source
}

# Invoke Context Orchestrator (sync/async) with retry logic
function Invoke-ContextSessionRpc {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Method,
        [Parameter(Mandatory = $true)]
        [hashtable]$Params,
        [switch]$Async
    )

    if (Test-IsInternalCall) {
        return $null
    }

    # Determine retry policy based on method
    $retryPolicy = switch ($Method) {
        "start_session" {
            @{
                MaxAttempts = 3
                Delays = @(500, 1000, 2000)  # Exponential backoff: 0.5s, 1s, 2s
            }
        }
        "add_command" {
            @{
                MaxAttempts = 2
                Delays = @(250, 250)  # Fixed 250ms delay
            }
        }
        default {
            @{
                MaxAttempts = 1
                Delays = @()  # No retry
            }
        }
    }

    $payload = @{
        jsonrpc = "2.0"
        id = (Get-Random -Minimum 1000 -Maximum 999999)
        method = $Method
        params = $Params
    } | ConvertTo-Json -Compress

    $scriptBlock = {
        param($payload)

        try {
            $python = Get-Command python -ErrorAction SilentlyContinue
            if (-not $python) {
                return $null
            }

            $previous = $env:CONTEXT_ORCHESTRATOR_INTERNAL
            $env:CONTEXT_ORCHESTRATOR_INTERNAL = "1"
            try {
                $output = $payload | & $python.Source -m src.main 2>&1
                return $output
            }
            finally {
                $env:CONTEXT_ORCHESTRATOR_INTERNAL = $previous
            }
        }
        catch {
            return $null
        }
    }

    if ($Async) {
        Start-Job -ScriptBlock $scriptBlock -ArgumentList $payload | Out-Null
        return $true
    }

    # Retry logic for synchronous calls
    $attempt = 0
    $lastError = $null

    while ($attempt -lt $retryPolicy.MaxAttempts) {
        $attempt++

        $output = & $scriptBlock $payload

        if ($output) {
            $jsonLine = $output | Select-Object -Last 1
            if ($jsonLine) {
                try {
                    $response = $jsonLine | ConvertFrom-Json -ErrorAction Stop
                    if ($response) {
                        return $response
                    }
                }
                catch {
                    $lastError = $_
                }
            }
        }

        # If this is not the last attempt, wait before retrying
        if ($attempt -lt $retryPolicy.MaxAttempts) {
            $delayMs = $retryPolicy.Delays[$attempt - 1]
            Start-Sleep -Milliseconds $delayMs
        }
    }

    # All retries failed
    if ($attempt -gt 1) {
        Write-Warning "[Context Orchestrator] $Method failed after $attempt attempts"
    }

    return $null
}

# Wrapper version (kept in profile for telemetry)
$ContextOrchestratorWrapperVersion = "2025.11.16"

# Helper: Get last timestamp from history.jsonl
function Get-HistoryLastTimestamp {
    param([string]$HistoryPath)

    if (-not (Test-Path $HistoryPath)) {
        return 0
    }

    try {
        $lastLine = Get-Content $HistoryPath -Tail 1 -Encoding UTF8 -ErrorAction SilentlyContinue
        if ($lastLine) {
            $entry = $lastLine | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($entry.timestamp) {
                return $entry.timestamp
            }
        }
    } catch {
        # Ignore errors
    }

    return 0
}

# Helper: Send history.jsonl entries to Context Orchestrator
function Send-HistoryEntries {
    param(
        [string]$HistoryPath,
        [long]$SinceTimestamp,
        [string]$Client,
        [string]$SessionId
    )

    if (-not (Test-Path $HistoryPath)) {
        return
    }

    # Verify session_id is provided
    if (-not $SessionId) {
        Write-Warning "[Context Orchestrator] Cannot send history entries: session_id not provided"
        return
    }

    try {
        # Determine field names based on client (Codex uses session_id/ts/text, Claude uses sessionId/timestamp/display)
        $sidField = if ($Client -eq 'codex') { 'session_id' } else { 'sessionId' }
        $tsField = if ($Client -eq 'codex') { 'ts' } else { 'timestamp' }
        $messageField = if ($Client -eq 'codex') { 'text' } else { 'display' }

        # Read recent entries (last 1000 lines to capture longer sessions)
        $hasSessionIdWarning = $false
        $entries = Get-Content $HistoryPath -Tail 1000 -Encoding UTF8 -ErrorAction SilentlyContinue |
            ForEach-Object {
                try { $_ | ConvertFrom-Json } catch { $null }
            } |
            Where-Object {
                if ($_ -eq $null) {
                    return $false
                }

                # Get values using client-specific field names
                $entrySid = $_.$sidField
                $entryTs = $_.$tsField
                $entryMessage = $_.$messageField

                # Warn once if entry has no session_id field
                if (-not $entrySid -and -not $hasSessionIdWarning) {
                    Write-Warning "[Context Orchestrator] History entry without $sidField found (skipping entries without session_id)"
                    $hasSessionIdWarning = $true
                }

                # Filter: must have timestamp after SinceTimestamp, message field, and session_id matching current session
                $_ -ne $null -and
                $entryTs -gt $SinceTimestamp -and
                $entryMessage -and
                $entrySid -eq $SessionId
            }

        # Prepare spool file path
        $spoolDir = Join-Path $env:USERPROFILE ".${Client}\sessions"
        if (-not (Test-Path $spoolDir)) {
            New-Item -ItemType Directory -Path $spoolDir -Force | Out-Null
        }
        $spoolPath = Join-Path $spoolDir "${SessionId}.jsonl"

        foreach ($entry in $entries) {
            try {
                # Get entry values using client-specific field names
                $entryMessage = $entry.$messageField
                $entryTs = $entry.$tsField

                # Save to spool file
                $entry | ConvertTo-Json -Compress | Add-Content -Path $spoolPath -Encoding UTF8

                # Send to Context Orchestrator
                # NOTE: project is intentionally left empty here. Automatic project assignment
                # is not performed by the wrapper. The ingestor will handle project assignment
                # based on cwd metadata, storing as unassigned memory if no project match.
                Invoke-ContextSessionRpc -Method "add_command" -Params @{
                    session_id = $SessionId
                    command = $entryMessage
                    output = ""
                    exit_code = 0
                    metadata = @{
                        client = $Client
                        source = "history_jsonl"
                        timestamp = $entryTs
                        project = ""  # Empty by design - ingestor assigns based on cwd
                        cwd = (Get-Location).Path
                    }
                } -Async | Out-Null
            } catch {
                # Ignore individual failures
            }
        }
    } catch {
        # Ignore errors
    }
}

# Wrapper for claude command
function claude {
    $realClaude = Resolve-CommandShim -Name "claude"

    if (Test-IsInternalCall) {
        & $realClaude @args
        return
    }

    # Check if this is an interactive session (no args or 'chat' command)
    $isInteractive = ($args.Length -eq 0 -or $args[0] -eq "chat")

    if ($isInteractive) {
        # Interactive mode: bypass Tee-Object to preserve real-time UX
        Write-Host "[Context Orchestrator] Interactive mode - logging deferred to history.jsonl" -ForegroundColor Cyan

        # Create session first to get session_id
        $sessionId = New-SessionId
        $sessionActive = $false

        $startResponse = Invoke-ContextSessionRpc -Method "start_session" -Params @{
            session_id = $sessionId
            metadata = @{
                client = "claude"
                mode = "interactive"
            }
        }

        if ($startResponse -and $startResponse.result -and $startResponse.result.session_id) {
            $sessionId = $startResponse.result.session_id
            $sessionActive = $true
        } else {
            Write-Warning "[Context Orchestrator] Failed to create session, history will not be recorded"
        }

        # Record history.jsonl timestamp before session
        $claudeHistoryPath = Join-Path $env:USERPROFILE ".claude\history.jsonl"
        $timestampBefore = Get-HistoryLastTimestamp -HistoryPath $claudeHistoryPath

        & $realClaude @args
        $exitCode = $LASTEXITCODE

        # Send new history entries to Context Orchestrator if session is active
        if ($sessionActive) {
            Send-HistoryEntries -HistoryPath $claudeHistoryPath -SinceTimestamp $timestampBefore -Client "claude" -SessionId $sessionId

            # End session
            Invoke-ContextSessionRpc -Method "end_session" -Params @{
                session_id = $sessionId
            } -Async | Out-Null
        }

        # Trigger Claude session ingestion in background if session is active
        if ($sessionActive) {
            Start-Job -WorkingDirectory $script:ContextOrchestratorRoot -ScriptBlock {
                param($ProjectRoot, $CurrentCwd)
                try {
                    # Ensure we're in the project root
                    Set-Location $ProjectRoot

                    $pythonExe = Get-Command python -ErrorAction SilentlyContinue
                    if (-not $pythonExe) {
                        return
                    }

                    $ingestorScript = Join-Path $ProjectRoot "scripts\claude_session_ingestor.py"
                    if (Test-Path $ingestorScript) {
                        # Run ingestor with current working directory
                        & python -m scripts.claude_session_ingestor --cwd $CurrentCwd 2>&1 | Out-Null
                    } else {
                        Write-Warning "Claude ingestor not found: $ingestorScript"
                    }
                } catch {
                    Write-Warning "Claude ingestion failed: $_"
                }
            } -ArgumentList $script:ContextOrchestratorRoot, (Get-Location).Path | Out-Null
        }

        # Set exit code without returning it (to prevent output pollution)
        $global:LASTEXITCODE = $exitCode
        return
    }

    # Non-interactive mode: use existing capture logic
    $commandArgs = ($args -join ' ')
    $command = ("claude $commandArgs").Trim()
    $sessionId = New-SessionId
    $sessionActive = $false

    $startResponse = Invoke-ContextSessionRpc -Method "start_session" -Params @{
        session_id = $sessionId
    }

    if ($startResponse -and $startResponse.result -and $startResponse.result.session_id) {
        $sessionId = $startResponse.result.session_id
        $sessionActive = $true
    }

    $startedAt = Get-Date
    & $realClaude @args 2>&1 |
        Tee-Object -Variable capturedOutput |
        Out-Host
    $exitCode = $LASTEXITCODE
    $finishedAt = Get-Date

    if ($sessionActive) {
        $metadata = @{
            client = "claude"
            binary = "claude"
            cwd = (Get-Location).Path
            shell = $PSVersionTable.PSEdition
            args = $commandArgs
            started_at = $startedAt.ToString("o")
            finished_at = $finishedAt.ToString("o")
            duration_seconds = [math]::Round(($finishedAt - $startedAt).TotalSeconds, 2)
            wrapper_version = $ContextOrchestratorWrapperVersion
            host = $env:COMPUTERNAME
        }

        Invoke-ContextSessionRpc -Method "add_command" -Params @{
            session_id = $sessionId
            command = $command
            output = ($capturedOutput -join "`n")
            exit_code = $exitCode
            metadata = $metadata
        } | Out-Null

        Invoke-ContextSessionRpc -Method "end_session" -Params @{
            session_id = $sessionId
        } -Async | Out-Null
    }

    return $exitCode
}

# Wrapper for codex command
function codex {
    $realCodex = Resolve-CommandShim -Name "codex"

    if (Test-IsInternalCall) {
        & $realCodex @args
        return
    }

    # Check if this is an interactive session (no args or non-exec commands)
    $isInteractive = ($args.Length -eq 0 -or $args[0] -notin @('exec', 'apply', '--help', '--version'))

    if ($isInteractive) {
        # Interactive mode: bypass Tee-Object to preserve real-time UX
        Write-Host "[Context Orchestrator] Interactive mode - Codex ingestion will run after exit" -ForegroundColor Cyan

        # Create session first to get session_id
        $sessionId = New-SessionId
        $sessionActive = $false

        $startResponse = Invoke-ContextSessionRpc -Method "start_session" -Params @{
            session_id = $sessionId
            metadata = @{
                client = "codex"
                mode = "interactive"
            }
        }

        if ($startResponse -and $startResponse.result -and $startResponse.result.session_id) {
            $sessionId = $startResponse.result.session_id
            $sessionActive = $true
        } else {
            Write-Warning "[Context Orchestrator] Failed to create session, history will not be recorded"
        }

        # Record history.jsonl timestamp before session
        $codexHistoryPath = Join-Path $env:USERPROFILE ".codex\history.jsonl"
        $timestampBefore = Get-HistoryLastTimestamp -HistoryPath $codexHistoryPath

        & $realCodex @args
        $exitCode = $LASTEXITCODE

        # Send new history entries to Context Orchestrator if session is active
        if ($sessionActive) {
            Send-HistoryEntries -HistoryPath $codexHistoryPath -SinceTimestamp $timestampBefore -Client "codex" -SessionId $sessionId

            # End session
            Invoke-ContextSessionRpc -Method "end_session" -Params @{
                session_id = $sessionId
            } -Async | Out-Null
        }

        # Trigger Codex session ingestion in background (Phase 3) if session is active
        if ($sessionActive) {
            Start-Job -WorkingDirectory $script:ContextOrchestratorRoot -ScriptBlock {
                param($ProjectRoot, $CurrentCwd)
                try {
                    # Ensure we're in the project root
                    Set-Location $ProjectRoot

                    $pythonExe = Get-Command python -ErrorAction SilentlyContinue
                    if (-not $pythonExe) {
                        return
                    }

                    $ingestorScript = Join-Path $ProjectRoot "scripts\codex_session_ingestor.py"
                    if (Test-Path $ingestorScript) {
                        # Run ingestor with current working directory
                        & python -m scripts.codex_session_ingestor --cwd $CurrentCwd 2>&1 | Out-Null
                    } else {
                        Write-Warning "Codex ingestor not found: $ingestorScript"
                    }
                } catch {
                    Write-Warning "Codex ingestion failed: $_"
                }
            } -ArgumentList $script:ContextOrchestratorRoot, (Get-Location).Path | Out-Null
        }

        # Set exit code without returning it (to prevent output pollution)
        $global:LASTEXITCODE = $exitCode
        return
    }

    # Non-interactive mode: use existing capture logic
    $commandArgs = ($args -join ' ')
    $command = ("codex $commandArgs").Trim()
    $sessionId = New-SessionId
    $sessionActive = $false

    $startResponse = Invoke-ContextSessionRpc -Method "start_session" -Params @{
        session_id = $sessionId
    }

    if ($startResponse -and $startResponse.result -and $startResponse.result.session_id) {
        $sessionId = $startResponse.result.session_id
        $sessionActive = $true
    }

    $startedAt = Get-Date
    & $realCodex @args 2>&1 |
        Tee-Object -Variable capturedOutput |
        Out-Host
    $exitCode = $LASTEXITCODE
    $finishedAt = Get-Date

    if ($sessionActive) {
        $metadata = @{
            client = "codex"
            binary = "codex"
            cwd = (Get-Location).Path
            shell = $PSVersionTable.PSEdition
            args = $commandArgs
            started_at = $startedAt.ToString("o")
            finished_at = $finishedAt.ToString("o")
            duration_seconds = [math]::Round(($finishedAt - $startedAt).TotalSeconds, 2)
            wrapper_version = $ContextOrchestratorWrapperVersion
            host = $env:COMPUTERNAME
        }

        Invoke-ContextSessionRpc -Method "add_command" -Params @{
            session_id = $sessionId
            command = $command
            output = ($capturedOutput -join "`n")
            exit_code = $exitCode
            metadata = $metadata
        } | Out-Null

        Invoke-ContextSessionRpc -Method "end_session" -Params @{
            session_id = $sessionId
        } -Async | Out-Null
    }

    return $exitCode
}

Write-Host "Context Orchestrator CLI recording enabled" -ForegroundColor Green
"@

function Install-Wrapper {
    Write-Host "Installing Context Orchestrator CLI recording wrapper..." -ForegroundColor Cyan

    # Check if profile exists
    if (-not (Test-Path $PROFILE)) {
        Write-Host "Creating PowerShell profile: $PROFILE" -ForegroundColor Yellow
        New-Item -Path $PROFILE -ItemType File -Force | Out-Null
    }

    # Read current profile
    $profileContent = Get-Content -Path $PROFILE -Raw -ErrorAction SilentlyContinue

    # Check if already installed
    if ($profileContent -match "Context Orchestrator CLI Recording Wrapper") {
        Write-Host "Wrapper already installed" -ForegroundColor Yellow
        return
    }

    # Append wrapper functions
    Add-Content -Path $PROFILE -Value "`n$WrapperFunctions"

    Write-Host "✁EWrapper installed to: $PROFILE" -ForegroundColor Green
    Write-Host ""
    Write-Host "Please restart PowerShell or run: . `$PROFILE" -ForegroundColor Yellow
}

function Uninstall-Wrapper {
    Write-Host "Uninstalling Context Orchestrator CLI recording wrapper..." -ForegroundColor Cyan

    # Check if profile exists
    if (-not (Test-Path $PROFILE)) {
        Write-Host "No profile found, nothing to uninstall" -ForegroundColor Yellow
        return
    }

    # Read current profile
    $profileContent = Get-Content -Path $PROFILE -Raw

    # Check if installed
    if ($profileContent -notmatch "Context Orchestrator CLI Recording Wrapper") {
        Write-Host "Wrapper not installed" -ForegroundColor Yellow
        return
    }

    # Remove wrapper section
    $newContent = $profileContent -replace "(?s)# Context Orchestrator CLI Recording Wrapper.*?Write-Host `"Context Orchestrator CLI recording enabled`".*?\n", ""

    # Write back
    Set-Content -Path $PROFILE -Value $newContent

    Write-Host "✁EWrapper uninstalled from: $PROFILE" -ForegroundColor Green
    Write-Host ""
    Write-Host "Please restart PowerShell" -ForegroundColor Yellow
}

# Main
if ($Install) {
    Install-Wrapper
}
elseif ($Uninstall) {
    Uninstall-Wrapper
}
else {
    Write-Host "Usage:"
    Write-Host "  Install:   .\setup_cli_recording.ps1 -Install"
    Write-Host "  Uninstall: .\setup_cli_recording.ps1 -Uninstall"
}
