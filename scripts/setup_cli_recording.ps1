# Context Orchestrator - PowerShell CLI Recording Wrapper
# Automatically wraps claude/codex commands to record sessions

<#
.SYNOPSIS
    Setup CLI recording wrapper for Context Orchestrator

.DESCRIPTION
    This script installs PowerShell functions that wrap claude/codex commands
    to automatically record sessions to Context Orchestrator.

.PARAMETER Install
    Install the wrapper functions to PowerShell profile

.PARAMETER Uninstall
    Remove the wrapper functions from PowerShell profile

.EXAMPLE
    .\setup_cli_recording.ps1 -Install
#>

param(
    [switch]$Install,
    [switch]$Uninstall
)

$WrapperFunctions = @'
# Context Orchestrator CLI Recording Wrapper
# Generated by setup_cli_recording.ps1

# Check if we're in an internal call (prevent recursion)
function Test-IsInternalCall {
    return $env:CONTEXT_ORCHESTRATOR_INTERNAL -eq "1"
}

# Generate session ID
function New-SessionId {
    return "session-$(Get-Date -Format 'yyyyMMdd-HHmmss')-$([guid]::NewGuid().ToString().Substring(0,8))"
}

# Resolve the real CLI shim instead of assuming an .exe is present
function Resolve-CommandShim {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name
    )

    $command = Get-Command $Name -CommandType Application,ExternalScript -ErrorAction SilentlyContinue | Select-Object -First 1

    if (-not $command) {
        throw "Context Orchestrator CLI recording wrapper could not locate '$Name'. Ensure it is installed and on PATH."
    }

    return $command.Source
}

# Invoke Context Orchestrator (sync/async)
function Invoke-ContextSessionRpc {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Method,
        [Parameter(Mandatory = $true)]
        [hashtable]$Params,
        [switch]$Async
    )

    if (Test-IsInternalCall) {
        return $null
    }

    $payload = @{
        jsonrpc = "2.0"
        id = (Get-Random -Minimum 1000 -Maximum 999999)
        method = $Method
        params = $Params
    } | ConvertTo-Json -Compress

    $scriptBlock = {
        param($payload)

        try {
            $python = Get-Command python -ErrorAction SilentlyContinue
            if (-not $python) {
                return $null
            }

            $previous = $env:CONTEXT_ORCHESTRATOR_INTERNAL
            $env:CONTEXT_ORCHESTRATOR_INTERNAL = "1"
            try {
                $output = $payload | & $python.Source -m src.main 2>&1
                return $output
            }
            finally {
                $env:CONTEXT_ORCHESTRATOR_INTERNAL = $previous
            }
        }
        catch {
            return $null
        }
    }

    if ($Async) {
        Start-Job -ScriptBlock $scriptBlock -ArgumentList $payload | Out-Null
        return $true
    }

    $output = & $scriptBlock $payload
    if (-not $output) {
        return $null
    }

    $jsonLine = $output | Select-Object -Last 1
    if (-not $jsonLine) {
        return $null
    }

    try {
        return $jsonLine | ConvertFrom-Json -ErrorAction Stop
    }
    catch {
        return $null
    }
}

# Wrapper version (kept in profile for telemetry)
$ContextOrchestratorWrapperVersion = "2025.11.16"

# Wrapper for claude command
function claude {
    $realClaude = Resolve-CommandShim -Name "claude"

    if (Test-IsInternalCall) {
        & $realClaude @args
        return
    }

    $commandArgs = ($args -join ' ')
    $command = ("claude $commandArgs").Trim()
    $sessionId = New-SessionId
    $sessionActive = $false

    $startResponse = Invoke-ContextSessionRpc -Method "start_session" -Params @{
        session_id = $sessionId
    }

    if ($startResponse -and $startResponse.result -and $startResponse.result.session_id) {
        $sessionId = $startResponse.result.session_id
        $sessionActive = $true
    }

    $startedAt = Get-Date
    $output = & $realClaude @args 2>&1 | Tee-Object -Variable capturedOutput
    $exitCode = $LASTEXITCODE
    $finishedAt = Get-Date

    if ($sessionActive) {
        $metadata = @{
            client = "claude"
            binary = "claude"
            cwd = (Get-Location).Path
            shell = $PSVersionTable.PSEdition
            args = $commandArgs
            started_at = $startedAt.ToString("o")
            finished_at = $finishedAt.ToString("o")
            duration_seconds = [math]::Round(($finishedAt - $startedAt).TotalSeconds, 2)
            wrapper_version = $ContextOrchestratorWrapperVersion
            host = $env:COMPUTERNAME
        }

        Invoke-ContextSessionRpc -Method "add_command" -Params @{
            session_id = $sessionId
            command = $command
            output = ($capturedOutput -join "`n")
            exit_code = $exitCode
            metadata = $metadata
        } | Out-Null

        Invoke-ContextSessionRpc -Method "end_session" -Params @{
            session_id = $sessionId
        } -Async | Out-Null
    }

    return $exitCode
}

# Wrapper for codex command
function codex {
    $realCodex = Resolve-CommandShim -Name "codex"

    if (Test-IsInternalCall) {
        & $realCodex @args
        return
    }

    $commandArgs = ($args -join ' ')
    $command = ("codex $commandArgs").Trim()
    $sessionId = New-SessionId
    $sessionActive = $false

    $startResponse = Invoke-ContextSessionRpc -Method "start_session" -Params @{
        session_id = $sessionId
    }

    if ($startResponse -and $startResponse.result -and $startResponse.result.session_id) {
        $sessionId = $startResponse.result.session_id
        $sessionActive = $true
    }

    $startedAt = Get-Date
    $output = & $realCodex @args 2>&1 | Tee-Object -Variable capturedOutput
    $exitCode = $LASTEXITCODE
    $finishedAt = Get-Date

    if ($sessionActive) {
        $metadata = @{
            client = "codex"
            binary = "codex"
            cwd = (Get-Location).Path
            shell = $PSVersionTable.PSEdition
            args = $commandArgs
            started_at = $startedAt.ToString("o")
            finished_at = $finishedAt.ToString("o")
            duration_seconds = [math]::Round(($finishedAt - $startedAt).TotalSeconds, 2)
            wrapper_version = $ContextOrchestratorWrapperVersion
            host = $env:COMPUTERNAME
        }

        Invoke-ContextSessionRpc -Method "add_command" -Params @{
            session_id = $sessionId
            command = $command
            output = ($capturedOutput -join "`n")
            exit_code = $exitCode
            metadata = $metadata
        } | Out-Null

        Invoke-ContextSessionRpc -Method "end_session" -Params @{
            session_id = $sessionId
        } -Async | Out-Null
    }

    return $exitCode
}

Write-Host "Context Orchestrator CLI recording enabled" -ForegroundColor Green
'@

function Install-Wrapper {
    Write-Host "Installing Context Orchestrator CLI recording wrapper..." -ForegroundColor Cyan

    # Check if profile exists
    if (-not (Test-Path $PROFILE)) {
        Write-Host "Creating PowerShell profile: $PROFILE" -ForegroundColor Yellow
        New-Item -Path $PROFILE -ItemType File -Force | Out-Null
    }

    # Read current profile
    $profileContent = Get-Content -Path $PROFILE -Raw -ErrorAction SilentlyContinue

    # Check if already installed
    if ($profileContent -match "Context Orchestrator CLI Recording Wrapper") {
        Write-Host "Wrapper already installed" -ForegroundColor Yellow
        return
    }

    # Append wrapper functions
    Add-Content -Path $PROFILE -Value "`n$WrapperFunctions"

    Write-Host "✁EWrapper installed to: $PROFILE" -ForegroundColor Green
    Write-Host ""
    Write-Host "Please restart PowerShell or run: . `$PROFILE" -ForegroundColor Yellow
}

function Uninstall-Wrapper {
    Write-Host "Uninstalling Context Orchestrator CLI recording wrapper..." -ForegroundColor Cyan

    # Check if profile exists
    if (-not (Test-Path $PROFILE)) {
        Write-Host "No profile found, nothing to uninstall" -ForegroundColor Yellow
        return
    }

    # Read current profile
    $profileContent = Get-Content -Path $PROFILE -Raw

    # Check if installed
    if ($profileContent -notmatch "Context Orchestrator CLI Recording Wrapper") {
        Write-Host "Wrapper not installed" -ForegroundColor Yellow
        return
    }

    # Remove wrapper section
    $newContent = $profileContent -replace "(?s)# Context Orchestrator CLI Recording Wrapper.*?Write-Host `"Context Orchestrator CLI recording enabled`".*?\n", ""

    # Write back
    Set-Content -Path $PROFILE -Value $newContent

    Write-Host "✁EWrapper uninstalled from: $PROFILE" -ForegroundColor Green
    Write-Host ""
    Write-Host "Please restart PowerShell" -ForegroundColor Yellow
}

# Main
if ($Install) {
    Install-Wrapper
}
elseif ($Uninstall) {
    Uninstall-Wrapper
}
else {
    Write-Host "Usage:"
    Write-Host "  Install:   .\setup_cli_recording.ps1 -Install"
    Write-Host "  Uninstall: .\setup_cli_recording.ps1 -Uninstall"
}
