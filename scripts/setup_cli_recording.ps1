# Context Orchestrator - PowerShell CLI Recording Wrapper
# Automatically wraps claude/codex commands to record sessions

<#
.SYNOPSIS
    Setup CLI recording wrapper for Context Orchestrator

.DESCRIPTION
    This script installs PowerShell functions that wrap claude/codex commands
    to automatically record sessions to Context Orchestrator.

.PARAMETER Install
    Install the wrapper functions to PowerShell profile

.PARAMETER Uninstall
    Remove the wrapper functions from PowerShell profile

.PARAMETER Force
    Force reinstall even if wrapper is already installed

.EXAMPLE
    .\setup_cli_recording.ps1 -Install

.EXAMPLE
    .\setup_cli_recording.ps1 -Install -Force
#>

param(
    [switch]$Install,
    [switch]$Uninstall,
    [switch]$Force
)

$WrapperFunctions = @'
# Context Orchestrator CLI Recording Wrapper
# Generated by setup_cli_recording.ps1

# Ensure UTF-8 output without BOM so JSON sent to python is parseable
$OutputEncoding = [System.Text.UTF8Encoding]::new($false)

# Resolve python, preferring local .venv/Scripts/python.exe
function Resolve-Python {
    param(
        [string]$StartDir = $(Get-Location).Path
    )

    # Try to find context-orchestrator repo root by walking up
    $current = $StartDir
    $maxDepth = 10
    $depth = 0

    while ($depth -lt $maxDepth) {
        # Check for .venv/Scripts/python.exe
        $venvPath = Join-Path $current ".venv\Scripts\python.exe"
        if (Test-Path $venvPath) {
            return $venvPath
        }

        # Check for .venv311/Scripts/python.exe (alternative)
        $venv311Path = Join-Path $current ".venv311\Scripts\python.exe"
        if (Test-Path $venv311Path) {
            return $venv311Path
        }

        # Check if we're at repo root (has src/ directory)
        $srcPath = Join-Path $current "src"
        if ((Test-Path $srcPath) -and (Test-Path (Join-Path $srcPath "main.py"))) {
            # We're at repo root but no .venv found, try PATH
            break
        }

        # Go up one level
        $parent = Split-Path -Parent $current
        if (-not $parent -or $parent -eq $current) {
            break
        }
        $current = $parent
        $depth++
    }

    # Fall back to python on PATH
    $pythonCmd = Get-Command python -ErrorAction SilentlyContinue
    if ($pythonCmd) {
        return $pythonCmd.Source
    }

    # Last resort: return null (will cause error later)
    return $null
}# Check if we're in an internal call (prevent recursion)
function Test-IsInternalCall {
    return $env:CONTEXT_ORCHESTRATOR_INTERNAL -eq "1"
}

# Generate session ID
function New-SessionId {
    return "session-$(Get-Date -Format 'yyyyMMdd-HHmmss')-$([guid]::NewGuid().ToString().Substring(0,8))"
}

# Resolve the real CLI shim instead of assuming an .exe is present
function Resolve-CommandShim {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name
    )

    $command = Get-Command $Name -CommandType Application,ExternalScript -ErrorAction SilentlyContinue | Select-Object -First 1

    if (-not $command) {
        throw "Context Orchestrator CLI recording wrapper could not locate '$Name'. Ensure it is installed and on PATH."
    }

    return $command.Source
}

# Invoke Context Orchestrator (sync/async)
function Invoke-ContextSessionRpc {
    param(
        [Parameter(Mandatory = $true)]
        [string]$Method,
        [Parameter(Mandatory = $true)]
        [hashtable]$Params,
        [switch]$Async
    )

    if (Test-IsInternalCall) {
        return $null
    }

    $payload = @{
        jsonrpc = "2.0"
        id = (Get-Random -Minimum 1000 -Maximum 999999)
        method = $Method
        params = $Params
    } | ConvertTo-Json -Compress

    $pythonPath = Resolve-Python
    if (-not $pythonPath) {
        return $null
    }

    # Resolve repo root from python path or environment variable
    $repoRoot = $null

    # 1. Try environment variable
    if ($env:CONTEXT_ORCHESTRATOR_ROOT) {
        $repoRoot = $env:CONTEXT_ORCHESTRATOR_ROOT
    }
    # 2. Try to derive from python path
    elseif ($pythonPath -match "[\\/]\.venv[\\/]Scripts[\\/]python\.exe$") {
        $repoRoot = Split-Path (Split-Path (Split-Path $pythonPath -Parent) -Parent) -Parent
    }
    elseif ($pythonPath -match "[\\/]\.venv311[\\/]Scripts[\\/]python\.exe$") {
        $repoRoot = Split-Path (Split-Path (Split-Path $pythonPath -Parent) -Parent) -Parent
    }
    # 3. Try to find from current directory
    else {
        $current = Get-Location
        $maxDepth = 10
        $depth = 0
        while ($depth -lt $maxDepth) {
            if ((Test-Path (Join-Path $current "src\main.py")) -and (Test-Path (Join-Path $current "config.yaml.template"))) {
                $repoRoot = $current.Path
                break
            }
            $parent = Split-Path -Parent $current
            if (-not $parent -or $parent -eq $current) {
                break
            }
            $current = $parent
            $depth++
        }
    }

    $scriptBlock = {
        param($payload, $pythonPath, $repoRoot)

        try {
            $previous = $env:CONTEXT_ORCHESTRATOR_INTERNAL
            $env:CONTEXT_ORCHESTRATOR_INTERNAL = "1"
            $previousPwd = Get-Location
            try {
                if ($repoRoot -and (Test-Path $repoRoot)) {
                    Set-Location $repoRoot
                }
                $output = $payload | & $pythonPath -m src.main 2>&1
                return $output
            }
            finally {
                if ($repoRoot) {
                    Set-Location $previousPwd
                }
                $env:CONTEXT_ORCHESTRATOR_INTERNAL = $previous
            }
        }
        catch {
            return $null
        }
    }

    if ($Async) {
        Start-Job -ScriptBlock $scriptBlock -ArgumentList $payload | Out-Null
        return $true
    }

    $output = & $scriptBlock $payload $pythonPath $repoRoot
    if (-not $output) {
        return $null
    }

    # Pick the first line that looks like JSON (logs go to stdout too)
    $jsonLine = ($output | ForEach-Object { $_.ToString() }) | Where-Object { $_ -and $_.Trim().StartsWith('{') } | Select-Object -First 1
    if (-not $jsonLine) {
        return $null
    }

    try {
        return $jsonLine | ConvertFrom-Json -ErrorAction Stop
    }
    catch {
        return $null
    }
}

# Wrapper version (kept in profile for telemetry)
$ContextOrchestratorWrapperVersion = "2025.11.25"

# Detect if output should be captured (non-interactive mode)
function Test-ShouldCaptureOutput {
    param([string]$CommandArgs)

    # Case 1: stdin is redirected (e.g., echo hi | claude)
    if ([Console]::IsInputRedirected) {
        return $true
    }

    # Case 2: --print flag is specified
    if ($CommandArgs -match '--print') {
        return $true
    }

    # Otherwise, interactive mode - preserve TTY
    return $false
}

# Wrapper for claude command
function claude {
    $realClaude = Resolve-CommandShim -Name "claude"

    if (Test-IsInternalCall) {
        & $realClaude @args
        return
    }

    $commandArgs = ($args -join ' ')
    $command = ("claude $commandArgs").Trim()
    $sessionId = New-SessionId
    $sessionActive = $false

    $startResponse = Invoke-ContextSessionRpc -Method "start_session" -Params @{
        session_id = $sessionId
    }

    if ($startResponse -and $startResponse.result -and $startResponse.result.session_id) {
        $sessionId = $startResponse.result.session_id
        $sessionActive = $true
    }

    $startedAt = Get-Date
    $capturedOutput = @()
    $shouldCapture = Test-ShouldCaptureOutput -CommandArgs $commandArgs

    $prevEAP = $ErrorActionPreference
    $ErrorActionPreference = 'SilentlyContinue'
    try {
        if ($shouldCapture) {
            # Non-interactive mode: capture output with Tee-Object
            # Pass stdin through pipeline if available
            $inputData = @($input)
            if ($inputData.Count -gt 0) {
                $inputData | & $realClaude @args 2>&1 |
                    Tee-Object -Variable capturedOutput |
                    Out-Host
            } else {
                & $realClaude @args 2>&1 |
                    Tee-Object -Variable capturedOutput |
                    Out-Host
            }
            $exitCode = $LASTEXITCODE
        } else {
            # Interactive mode: preserve TTY, capture via transcript (so TTY is kept)
            $transcriptFile = Join-Path $env:TEMP "co_transcript_$sessionId.txt"
            $transcriptStarted = $false
            try {
                Start-Transcript -Path $transcriptFile -Force -ErrorAction Stop | Out-Null
                $transcriptStarted = $true
            } catch {
                $transcriptStarted = $false
            }

            & $realClaude @args
            $exitCode = $LASTEXITCODE

            if ($transcriptStarted) {
                try { Stop-Transcript | Out-Null } catch {}
                if (Test-Path $transcriptFile) {
                    try {
                        $capturedOutput = Get-Content -Path $transcriptFile -Raw -ErrorAction SilentlyContinue
                    } catch {
                        $capturedOutput = ""
                    }
                    try { Remove-Item -Path $transcriptFile -Force -ErrorAction SilentlyContinue } catch {}
                }
            }
        }
    }
    finally {
        $ErrorActionPreference = $prevEAP
    }

    $finishedAt = Get-Date

    if ($sessionActive) {
        $metadata = @{
            client = "claude"
            binary = "claude"
            cwd = (Get-Location).Path
            shell = $PSVersionTable.PSEdition
            args = $commandArgs
            started_at = $startedAt.ToString("o")
            finished_at = $finishedAt.ToString("o")
            duration_seconds = [math]::Round(($finishedAt - $startedAt).TotalSeconds, 2)
            wrapper_version = $ContextOrchestratorWrapperVersion
            host = $env:COMPUTERNAME
            interactive = -not $shouldCapture
        }

        Invoke-ContextSessionRpc -Method "add_command" -Params @{
            session_id = $sessionId
            command = $command
            output = ($capturedOutput -join "`n")
            exit_code = $exitCode
            metadata = $metadata
        } | Out-Null

        Invoke-ContextSessionRpc -Method "end_session" -Params @{
            session_id = $sessionId
        } -Async | Out-Null
    }

    return $exitCode
}

# Wrapper for codex command
function codex {
    $realCodex = Resolve-CommandShim -Name "codex"

    if (Test-IsInternalCall) {
        & $realCodex @args
        return
    }

        $commandArgs = ($args -join ' ')
        $command = ("codex $commandArgs").Trim()
    $sessionId = New-SessionId
    $sessionActive = $false

    $startResponse = Invoke-ContextSessionRpc -Method "start_session" -Params @{
        session_id = $sessionId
    }

    if ($startResponse -and $startResponse.result -and $startResponse.result.session_id) {
        $sessionId = $startResponse.result.session_id
        $sessionActive = $true
    }

    $startedAt = Get-Date
    $capturedOutput = @()
    $shouldCapture = Test-ShouldCaptureOutput -CommandArgs $commandArgs

    $prevEAP = $ErrorActionPreference
    $ErrorActionPreference = 'Continue'
    try {
        if ($shouldCapture) {
            # Non-interactive mode: capture output with Tee-Object
            # Pass stdin through pipeline if available
            $inputData = @($input)
            if ($inputData.Count -gt 0) {
                $inputData | & $realCodex @args 2>&1 |
                    Tee-Object -Variable capturedOutput |
                    Out-Host
            } else {
                & $realCodex @args 2>&1 |
                    Tee-Object -Variable capturedOutput |
                    Out-Host
            }
            $exitCode = $LASTEXITCODE
        } else {
            # Interactive mode: preserve TTY, capture via transcript
            $transcriptFile = Join-Path $env:TEMP "co_transcript_$sessionId.txt"
            $transcriptStarted = $false
            try {
                Start-Transcript -Path $transcriptFile -Force -ErrorAction Stop | Out-Null
                $transcriptStarted = $true
            } catch {
                $transcriptStarted = $false
            }

            & $realCodex @args
            $exitCode = $LASTEXITCODE

            if ($transcriptStarted) {
                try { Stop-Transcript | Out-Null } catch {}
                if (Test-Path $transcriptFile) {
                    try {
                        $capturedOutput = Get-Content -Path $transcriptFile -Raw -ErrorAction SilentlyContinue
                    } catch {
                        $capturedOutput = ""
                    }
                    try { Remove-Item -Path $transcriptFile -Force -ErrorAction SilentlyContinue } catch {}
                }
            }
        }
    }
    finally {
        $ErrorActionPreference = $prevEAP
    }

    $finishedAt = Get-Date

    if ($sessionActive) {
        $metadata = @{
            client = "codex"
            binary = "codex"
            cwd = (Get-Location).Path
            shell = $PSVersionTable.PSEdition
            args = $commandArgs
            started_at = $startedAt.ToString("o")
            finished_at = $finishedAt.ToString("o")
            duration_seconds = [math]::Round(($finishedAt - $startedAt).TotalSeconds, 2)
            wrapper_version = $ContextOrchestratorWrapperVersion
            host = $env:COMPUTERNAME
            interactive = -not $shouldCapture
        }

        Invoke-ContextSessionRpc -Method "add_command" -Params @{
            session_id = $sessionId
            command = $command
            output = ($capturedOutput -join "`n")
            exit_code = $exitCode
            metadata = $metadata
        } | Out-Null

        Invoke-ContextSessionRpc -Method "end_session" -Params @{
            session_id = $sessionId
        } -Async | Out-Null
    }

    return $exitCode
}

Write-Host "Context Orchestrator CLI recording enabled" -ForegroundColor Green

# Auto-start log bridge if available
$logBridgeScript = Join-Path (Split-Path -Parent $PSScriptRoot) "scripts\start_log_bridge.ps1"
if (Test-Path $logBridgeScript) {
    try {
        & $logBridgeScript
    } catch {
        Write-Host "[Context Orchestrator] Warning: Failed to start log bridge: $_" -ForegroundColor Yellow
    }
}
'@

function Install-Wrapper {
    Write-Host "Installing Context Orchestrator CLI recording wrapper..." -ForegroundColor Cyan

    # Check if profile exists
    if (-not (Test-Path $PROFILE)) {
        Write-Host "Creating PowerShell profile: $PROFILE" -ForegroundColor Yellow
        New-Item -Path $PROFILE -ItemType File -Force | Out-Null
    }

    # Read current profile
    $profileContent = Get-Content -Path $PROFILE -Raw -ErrorAction SilentlyContinue

    # Check if already installed
    if ($profileContent -match "Context Orchestrator CLI Recording Wrapper") {
        if ($Force) {
            Write-Host "Wrapper already installed, forcing reinstall..." -ForegroundColor Yellow
            # Remove old wrapper
            $newContent = $profileContent -replace "(?s)# Context Orchestrator CLI Recording Wrapper.*?Write-Host `"Context Orchestrator CLI recording enabled`".*?\n", ""
            Set-Content -Path $PROFILE -Value $newContent
            # Append new wrapper
            Add-Content -Path $PROFILE -Value "`n$WrapperFunctions"
            Write-Host "Wrapper reinstalled to: $PROFILE" -ForegroundColor Green
        } else {
            Write-Host "Wrapper already installed (use -Force to reinstall)" -ForegroundColor Yellow
            return
        }
    } else {
        # Append wrapper functions
        Add-Content -Path $PROFILE -Value "`n$WrapperFunctions"
        Write-Host "Wrapper installed to: $PROFILE" -ForegroundColor Green
    }

    Write-Host ""
    Write-Host "Please restart PowerShell or run: . `$PROFILE" -ForegroundColor Yellow
}

function Uninstall-Wrapper {
    Write-Host "Uninstalling Context Orchestrator CLI recording wrapper..." -ForegroundColor Cyan

    # Check if profile exists
    if (-not (Test-Path $PROFILE)) {
        Write-Host "No profile found, nothing to uninstall" -ForegroundColor Yellow
        return
    }

    # Read current profile
    $profileContent = Get-Content -Path $PROFILE -Raw

    # Check if installed
    if ($profileContent -notmatch "Context Orchestrator CLI Recording Wrapper") {
        Write-Host "Wrapper not installed" -ForegroundColor Yellow
        return
    }

    # Remove wrapper section
    $newContent = $profileContent -replace "(?s)# Context Orchestrator CLI Recording Wrapper.*?Write-Host `"Context Orchestrator CLI recording enabled`".*?\n", ""

    # Write back
    Set-Content -Path $PROFILE -Value $newContent

    Write-Host "笨・Wrapper uninstalled from: $PROFILE" -ForegroundColor Green
    Write-Host ""
    Write-Host "Please restart PowerShell" -ForegroundColor Yellow
}

# Main
if ($Install) {
    Install-Wrapper
}
elseif ($Uninstall) {
    Uninstall-Wrapper
}
else {
    Write-Host "Usage:"
    Write-Host "  Install:   .\setup_cli_recording.ps1 -Install"
    Write-Host "  Uninstall: .\setup_cli_recording.ps1 -Uninstall"
}


